/*
 * Copyright 2014â€“2016 SlamData Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ygg.tests

import scalaz._, Scalaz._
import ygg._, common._, data._, json._, table._
import trans.DerefObjectStatic

abstract class TableQspec extends quasar.Qspec with TableModuleTestSupport {
  self =>

  import SampleData._

  type ToSelf[A] = A => A
  type ASD       = Arbitrary[SampleData]
  type TTable    = Table { type Table = self.Table }

  /* Oh cake, my cake, the crimes you make me commit */
  private implicit def ttable(x: Table): TTable = x.asInstanceOf[TTable]

  trait CommuteTest[R, S] {
    def transformR(x: R): R
    def transformS(x: S): S
    def rToS(x: R): S
    def sToR(x: S): R

    def checkOneR(x: R)(implicit ze: Eq[R], zs: Show[R]): MatchResult[R]  = transformR(x) must_= sToR(transformS(rToS(x)))
    def checkR()(implicit za: Arbitrary[R], ze: Eq[R], zs: Show[R]): Prop = prop(checkOneR _)
  }

  class TableCommuteTest(f: Seq[JValue] => Seq[JValue], g: Table => Table) extends CommuteTest[Seq[JValue], Table] {
    def transformR(x: Seq[JValue])  = f(x)
    def transformS(x: Table)        = g(x)
    def rToS(x: Seq[JValue]): Table = fromJson(x)
    def sToR(x: Table): Seq[JValue] = toJson(x).copoint
  }

  implicit class SampleDataOps(private val sd: SampleData) {
    def fieldHead = sd.schema.get._2.head._1.head.get
    def fieldHeadName: String = fieldHead match {
      case JPathField(s) => s
      case _             => abort("non-field reached")
    }
    def fieldHeadIndex: Int = fieldHead match {
      case JPathIndex(s) => s
      case _             => abort("non-index reached")
    }
  }

  case class TableTestFun(table: Table, fun: Table => Table, expected: Seq[JValue]) {
    def check(): MatchResult[Seq[JValue]] = (toJson(fun(table)).copoint: Seq[JValue]) must_=== expected
  }
  case class TableTest(table: TTable, spec: TransSpec1, expected: Seq[JValue]) {
    def check(): MatchResult[Seq[JValue]] = toJsonSeq(table transform spec) must_=== expected
  }
  case class TableProp(f: SampleData => TableTest) {
    def check()(implicit z: ASD): Prop = prop((sd: SampleData) => f(sd).check())
  }

  /** Verify a scalacheck property that for any SampleData generated by the implicit ASD,
   *  generating a table and transforming it with `spec` produces a copoint which is equal
   *  to the result of the function `expect` applied to the original data.
   */
  def checkSpec(spec: TransSpec1)(expect: ToSelf[Seq[JValue]])(implicit z: ASD): Prop =
    TableProp(sd => TableTest(fromSample(sd), spec, expect(sd.data))).check()

  def checkCommutes(f: Seq[JValue] => Seq[JValue], g: Table => Table, gen: Gen[Seq[JValue]]): Prop = {
    implicit val za: Arbitrary[Seq[JValue]] = Arbitrary(gen)
    implicit val ze: Eq[Seq[JValue]]        = Eq.equal((x, y) => (x corresponds y)(_ == _))
    implicit val zs: Show[Seq[JValue]]      = Show.shows(_.toString)

    new TableCommuteTest(f, g).checkR()
  }

  def checkSpecDefault(spec: TransSpec1)(expect: ToSelf[Seq[JValue]]): Prop =
    checkSpec(spec)(expect)(defaultASD)

  def checkSpecData(spec: TransSpec1, data: Seq[JValue], expected: Seq[JValue]): Prop =
    TableTest(fromJson(data), spec, expected).check()

  def checkTableFun(fun: Table => Table, data: Seq[JValue], expected: Seq[JValue]): Prop = checkTableFun(fun, fromJson(data), expected)
  def checkTableFun(fun: Table => Table, table: Table, expected: Seq[JValue]): Prop      = TableTestFun(table, fun, expected).check()

  def checkSpecDataId(spec: TransSpec1, data: Seq[JValue]): Prop =
    checkSpecData(spec, data, data)

  protected def defaultASD: ASD                                           = sample(schema)
  protected def select[A](qual: TransSpec[A], name: String): TransSpec[A] = DerefObjectStatic(qual, CPathField(name))
  protected def select(name: String): TransSpec1                          = select(Fn.source, name)
}

abstract class ColumnarTableQspec extends TableQspec with ColumnarTableModuleTestSupport {
  outer =>

  final object Table extends TableCompanion

  final class Table(slices: NeedSlices, size: TableSize) extends ColumnarTable(slices, size) with NoLoadTable with NoSortTable with NoGroupTable {
    def companion = Table
    // Deadlock
    // override def toString = toJson.value.mkString("TABLE{ ", ", ", "}")
  }
  trait TableCompanion extends ColumnarTableCompanion {
    def apply(slices: NeedSlices, size: TableSize): Table                                        = new Table(slices, size)
    def singleton(slice: Slice): Table                                                                     = new Table(slice :: StreamT.empty[Need, Slice], ExactSize(1))
    def align(sourceL: Table, alignL: TransSpec1, sourceR: Table, alignR: TransSpec1): Need[PairOf[Table]] = ???
  }

  def sanitize(s: String): String = s.toArray.map(c => if (c < ' ') ' ' else c).mkString("")
}

trait TableModuleTestSupport extends TableModule {
  outer =>

  def lookupScanner(namespace: List[String], name: String): Scanner = {
    val lib = Map[String, Scanner](
      "sum" -> new Scanner {
        type A = BigDecimal
        val init = BigDecimal(0)
        def scan(a: BigDecimal, cols: Map[ColumnRef, Column], range: Range): (A, Map[ColumnRef, Column]) = {
          val identityPath = cols collect { case c @ (ColumnRef.id(_), _) => c }
          val prioritized = identityPath.values filter {
            case (_: LongColumn | _: DoubleColumn | _: NumColumn) => true
            case _                                                => false
          }

          val mask = Bits.filteredRange(range.start, range.end) { i =>
            prioritized exists { _ isDefinedAt i }
          }

          val (a2, arr) = mask.toList.foldLeft((a, new Array[BigDecimal](range.end))) {
            case ((acc, arr), i) => {
              val col = prioritized find { _ isDefinedAt i }

              val acc2 = col map {
                case lc: LongColumn   => acc + lc(i)
                case dc: DoubleColumn => acc + dc(i)
                case nc: NumColumn    => acc + nc(i)
                case _                => abort("unreachable")
              }

              acc2 foreach { arr(i) = _ }

              (acc2 getOrElse acc, arr)
            }
          }

          (a2, Map(ColumnRef.id(CNum) -> ArrayNumColumn(mask, arr)))
        }
      }
    )

    lib(name)
  }

  def fromJson(data: Seq[JValue], maxBlockSize: Option[Int]): Table

  def toJson(dataset: Table): Need[Stream[JValue]]                         = dataset.toJson.map(_.toStream)
  def toJsonSeq(table: Table): Seq[JValue]                                 = toJson(table).copoint
  def fromJson(data: Seq[JValue]): Table                                   = fromJson(data, None)
  def fromJson(data: Seq[JValue], maxBlockSize: Int): Table                = fromJson(data, Some(maxBlockSize))
  def fromSample(sampleData: SampleData): Table                            = fromJson(sampleData.data, None)
  def fromSample(sampleData: SampleData, maxBlockSize: Option[Int]): Table = fromJson(sampleData.data, maxBlockSize)
}
